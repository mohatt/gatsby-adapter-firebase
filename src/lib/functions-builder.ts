import path from 'node:path'
import fs from 'node:fs/promises'
import type { FunctionsManifest, Reporter } from 'gatsby'
import type { FunctionExport, PreparedFunctions } from './types.js'
import { copyFileWithDirs, ensureEmptyDir, relativeTo, toPosix } from './utils.js'

export type FunctionsBuilderOptions = {
  functions: FunctionsManifest
  outDir: string
  projectRoot: string
  reporter: Reporter
  runtime: string
}

export type FunctionsBuilderResult = {
  prepared: PreparedFunctions | null
  idMap: Map<string, string>
}

const sanitizeFunctionName = (value: string, used: Set<string>) => {
  const base = value
    .replace(/[^A-Za-z0-9_$]/g, '_')
    .replace(/_{2,}/g, '_')
    .replace(/^_+/, '')
  const prefixed = /^[A-Za-z_$]/.test(base) ? base || 'fn' : `fn_${base}`
  let candidate = prefixed || 'fn'
  let counter = 1
  while (used.has(candidate)) {
    candidate = `${prefixed}_${counter++}`
  }
  used.add(candidate)
  return candidate
}

const resolveEntryRelativePath = (outDir: string, entry: string) => {
  const rel = relativeTo(outDir, entry)
  if (rel.startsWith('../') || rel.startsWith('./')) {
    return rel
  }
  return `./${rel}`
}

const createIndexSource = (exportsInfo: FunctionExport[]) => {
  if (exportsInfo.length === 0) return ''

  return `// Auto-generated by gatsby-adapter-firebase. Do not edit.
'use strict'

const { onRequest } = require('firebase-functions/v2/https')

const createHttpsFunction = (handlerExports) => {
  const handler = handlerExports?.default || handlerExports
  const options = handlerExports?.options
  if (options && typeof options === 'object') {
    return onRequest(options, handler)
  }
  return onRequest(handler)
}

${exportsInfo
  .map((fn) => `exports.${fn.deployedId} = createHttpsFunction(require('${fn.relativeEntry}'))`)
  .join('\n')}
`
}

const assertSafeOutDir = (projectRoot: string, outDir: string) => {
  const resolvedRoot = path.resolve(projectRoot)
  const resolvedOutDir = path.resolve(outDir)
  if (resolvedRoot === resolvedOutDir) {
    throw new Error('[gatsby-adapter-firebase] functionsOutDir must not be the project root')
  }
}

const normalizeRelativePath = (value: string, projectRoot: string) => {
  const absolute = path.isAbsolute(value) ? value : path.join(projectRoot, value)
  return path.resolve(absolute)
}

const isWithin = (parent: string, child: string) => {
  const relative = path.relative(parent, child)
  return relative === '' || (!relative.startsWith('..') && !path.isAbsolute(relative))
}

const runtimeToEngineConstraint = (runtime: string) => {
  const match = /^nodejs(\d+)/.exec(runtime)
  if (!match) return undefined
  const major = Number(match[1])
  if (!Number.isInteger(major)) return undefined
  return `>=${major}`
}

export const prepareFunctionsWorkspace = async (
  options: FunctionsBuilderOptions,
): Promise<FunctionsBuilderResult> => {
  const { functions, outDir, projectRoot, reporter, runtime } = options

  const idMap = new Map<string, string>()

  if (!functions.length) {
    try {
      await fs.rm(outDir, { recursive: true, force: true })
    } catch (error) {
      reporter.warn(
        `[gatsby-adapter-firebase] Failed to clean empty functions directory ${toPosix(outDir)}: ${(error as Error).message}`,
      )
    }
    return { prepared: null, idMap }
  }

  assertSafeOutDir(projectRoot, outDir)

  await ensureEmptyDir(outDir)

  const usedNames = new Set<string>()
  const exportsInfo: FunctionExport[] = []
  const copiedFiles = new Set<string>()

  for (const fn of functions) {
    if (idMap.has(fn.functionId)) {
      reporter.warn(
        `[gatsby-adapter-firebase] Duplicate functionId "${fn.functionId}" detected; keeping the first definition only.`,
      )
      continue
    }
    const deployedId = sanitizeFunctionName(fn.functionId, usedNames)
    idMap.set(fn.functionId, deployedId)

    const entryAbsolute = normalizeRelativePath(fn.pathToEntryPoint, projectRoot)
    const entryRelativeFromRoot = path.relative(projectRoot, entryAbsolute)
    const entryDestination = path.resolve(outDir, entryRelativeFromRoot)
    if (!isWithin(outDir, entryDestination)) {
      reporter.warn(
        `[gatsby-adapter-firebase] Function entry ${toPosix(fn.pathToEntryPoint)} resolves outside of the configured functionsOutDir; skipping deployment of ${fn.functionId}.`,
      )
      idMap.delete(fn.functionId)
      continue
    }

    const required = new Set<string>(fn.requiredFiles)
    required.add(fn.pathToEntryPoint)

    let entryCopied = false
    let copyFailed = false

    for (const file of required) {
      const absolute = normalizeRelativePath(file, projectRoot)
      const relativeFromRoot = path.relative(projectRoot, absolute)
      const destination = path.resolve(outDir, relativeFromRoot)
      if (!isWithin(outDir, destination)) {
        reporter.warn(
          `[gatsby-adapter-firebase] Skipping required file outside workspace: ${toPosix(file)}`,
        )
        continue
      }
      try {
        await copyFileWithDirs(absolute, destination)
        copiedFiles.add(toPosix(relativeFromRoot))
        if (absolute === entryAbsolute) {
          entryCopied = true
        }
      } catch (error) {
        reporter.warn(
          `[gatsby-adapter-firebase] Failed to copy required file ${toPosix(file)}: ${(error as Error).message}`,
        )
        if (absolute === entryAbsolute) {
          copyFailed = true
        }
      }
    }

    if (!entryCopied || copyFailed) {
      reporter.warn(
        `[gatsby-adapter-firebase] Skipping function ${fn.functionId} because its entry file could not be copied.`,
      )
      idMap.delete(fn.functionId)
      continue
    }

    exportsInfo.push({
      originalId: fn.functionId,
      deployedId,
      relativeEntry: resolveEntryRelativePath(outDir, entryDestination),
    })
  }

  if (!exportsInfo.length) {
    try {
      await fs.rm(outDir, { recursive: true, force: true })
    } catch (error) {
      reporter.warn(
        `[gatsby-adapter-firebase] Failed to clean functions directory ${toPosix(outDir)} after skipping functions: ${(error as Error).message}`,
      )
    }
    idMap.clear()
    return { prepared: null, idMap }
  }

  const indexSource = createIndexSource(exportsInfo)
  await fs.writeFile(path.join(outDir, 'index.js'), indexSource, 'utf8')

  const enginesEntry = runtimeToEngineConstraint(runtime)
  const packageJson = {
    type: 'commonjs',
    ...(enginesEntry ? { engines: { node: enginesEntry } } : {}),
    dependencies: {
      'firebase-functions': '^4.4.0',
    },
  }

  await fs.writeFile(
    path.join(outDir, 'package.json'),
    JSON.stringify(packageJson, null, 2),
    'utf8',
  )

  return { prepared: { exports: exportsInfo, copiedFiles }, idMap }
}
